package events

import (
	"time"

	"github.com/flanksource/commons/logger"
	"github.com/flanksource/duty/upstream"
	"github.com/flanksource/incident-commander/api"
	"github.com/flanksource/postq"
	"github.com/flanksource/postq/pg"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
)

const (
	// eventQueueUpdateChannel is the channel on which new events on the `event_queue` table
	// are notified.
	eventQueueUpdateChannel = "event_queue_updates"
)

// List of all sync events in the `event_queue` table.
//
// These events are generated by the database in response to updates on some of the tables.
const (
	EventCheckPassed = "check.passed"
	EventCheckFailed = "check.failed"

	EventComponentStatusHealthy   = "component.status.healthy"
	EventComponentStatusUnhealthy = "component.status.unhealthy"
	EventComponentStatusInfo      = "component.status.info"
	EventComponentStatusWarning   = "component.status.warning"
	EventComponentStatusError     = "component.status.error"

	EventPlaybookSpecApprovalUpdated = "playbook.spec.approval.updated"

	EventPlaybookApprovalInserted = "playbook.approval.inserted"

	EventIncidentCommentAdded        = "incident.comment.added"
	EventIncidentCreated             = "incident.created"
	EventIncidentDODAdded            = "incident.dod.added"
	EventIncidentDODPassed           = "incident.dod.passed"
	EventIncidentDODRegressed        = "incident.dod.regressed"
	EventIncidentResponderAdded      = "incident.responder.added"
	EventIncidentResponderRemoved    = "incident.responder.removed"
	EventIncidentStatusCancelled     = "incident.status.cancelled"
	EventIncidentStatusClosed        = "incident.status.closed"
	EventIncidentStatusInvestigating = "incident.status.investigating"
	EventIncidentStatusMitigated     = "incident.status.mitigated"
	EventIncidentStatusOpen          = "incident.status.open"
	EventIncidentStatusResolved      = "incident.status.resolved"
)

// List of async events.
//
// Async events require the handler to talk to 3rd party services.
// They are not determinant and cannot be reliably rolled back and retried.
//
// They are mostly generated by the application itself from sync consumers in response
// to a sync event.
// Or, they could also be generated by the database.
const (
	EventPushQueueCreate = "push_queue.create"

	EventNotificationSend = "notification.send"

	EventJiraResponderAdded = "incident.responder.jira.added"
	EventJiraCommentAdded   = "incident.comment.jira.added"

	EventMSPlannerResponderAdded = "incident.responder.msplanner.added"
	EventMSPlannerCommentAdded   = "incident.comment.msplanner.added"
)

func StartConsumers(ctx api.Context, upstreamConfig upstream.UpstreamConfig) {
	// We listen to all PG Notifications on one channel and distribute it to other consumers
	// based on the events.
	notifyRouter := pg.NewNotifyRouter()
	go notifyRouter.Run(ctx, eventQueueUpdateChannel)

	uniqEvents := make(map[string]struct{})
	allSyncHandlers := []postq.SyncEventConsumer{
		NewCheckConsumerSync(),
		NewComponentConsumerSync(),
		NewResponderConsumerSync(),
		NewCommentConsumerSync(),
		NewNotificationSaveConsumerSync(),
		NewPlaybookApprovalConsumerSync(),
		NewPlaybookApprovalSpecUpdatedConsumerSync(),
	}

	for i := range allSyncHandlers {
		for _, event := range allSyncHandlers[i].WatchEvents {
			if _, ok := uniqEvents[event]; ok {
				logger.Fatalf("Watch event %s is duplicated", event)
			}

			uniqEvents[event] = struct{}{}
		}

		pgNotifyChannel := notifyRouter.RegisterRoutes(allSyncHandlers[i].WatchEvents...)
		if ec, err := allSyncHandlers[i].EventConsumer(); err != nil {
			logger.Fatalf("failed to create event consumer: %s", err)
		} else {
			go ec.Listen(ctx, pgNotifyChannel)
		}
	}

	asyncConsumers := []postq.AsyncEventConsumer{
		NewNotificationSendConsumerAsync(),
		NewResponderConsumerAsync(),
	}
	if upstreamConfig.Valid() {
		asyncConsumers = append(asyncConsumers, upstream.NewPushQueueConsumer(upstreamConfig))
	}

	for i := range asyncConsumers {
		for _, event := range asyncConsumers[i].WatchEvents {
			if _, ok := uniqEvents[event]; ok {
				logger.Fatalf("Watch event %s is duplicated", event)
			}

			uniqEvents[event] = struct{}{}
		}

		pgNotifyChannel := notifyRouter.RegisterRoutes(asyncConsumers[i].WatchEvents...)
		if ec, err := asyncConsumers[i].EventConsumer(); err != nil {
			logger.Fatalf("failed to create event consumer: %s", err)
		} else {
			go ec.Listen(ctx, pgNotifyChannel)
		}
	}
}

// on conflict clause when inserting new events to the `event_queue` table
var eventQueueOnConflictClause = clause.OnConflict{
	Columns: []clause.Column{{Name: "name"}, {Name: "properties"}},
	DoUpdates: clause.Assignments(map[string]any{
		"attempts":     0,
		"last_attempt": nil,
		"created_at":   gorm.Expr("NOW()"),
		"error":        clause.Column{Table: "excluded", Name: "error"},
	}),
}

func defaultLoggerErrorHandler(err error) bool {
	logger.Errorf("error consuming: %v", err)
	time.Sleep(time.Second * 5)
	return true
}
